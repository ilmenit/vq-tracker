"""Tests for the all-RAW build pipeline VQ_CFG patching.

When the VQ converter runs in algo=raw mode (all instruments are RAW
samples), it writes ALGO_RAW=1 to VQ_CFG.asm but omits MIN_VECTOR,
ALGO_FIXED, MULTI_SAMPLE, and PITCH_CONTROL. The tracker player
requires all of these. The build pipeline must inject them.
"""
import sys, os, unittest, tempfile, shutil
sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))


def _make_raw_vq_cfg(path):
    """Write a VQ_CFG.asm as the converter would for algo=raw mode."""
    with open(path, 'w') as f:
        f.write("; Configuration generated by PokeyVQ\n")
        f.write("PLAY_RATE = $04\n")
        f.write("CHANNELS = 4\n")
        f.write("AUDCTL_VAL = $00\n")
        f.write("AUDF1_VAL = PLAY_RATE\n")
        f.write("AUDC1_MASK = $10 ; Vol Only\n")
        f.write("AUDC2_MASK = $10 ; Vol Only\n")
        f.write("IRQ_MASK = 1   ; Timer 1\n")
        f.write("ALGO_RAW = 1\n")
        # Note: NO MIN_VECTOR, ALGO_FIXED, MULTI_SAMPLE, PITCH_CONTROL


def _make_vq_vq_cfg(path):
    """Write a VQ_CFG.asm as the converter would for algo=fixed (VQ) mode."""
    with open(path, 'w') as f:
        f.write("; Configuration generated by PokeyVQ\n")
        f.write("PLAY_RATE = $04\n")
        f.write("CHANNELS = 4\n")
        f.write("AUDCTL_VAL = $00\n")
        f.write("AUDF1_VAL = PLAY_RATE\n")
        f.write("AUDC1_MASK = $10 ; Vol Only\n")
        f.write("AUDC2_MASK = $10 ; Vol Only\n")
        f.write("IRQ_MASK = 1   ; Timer 1\n")
        f.write("ALGO_FIXED = 1\n")
        f.write("MIN_VECTOR = 8\n")
        f.write("MAX_VECTOR = 8\n")
        f.write("CODEBOOK_SIZE = 256\n")
        f.write("MULTI_SAMPLE = 1\n")
        f.write("PITCH_CONTROL = 1\n")


def _simulate_vq_cfg_patch(vq_cfg_path, vec_size=8, has_vq=False):
    """Simulate the build.py VQ_CFG patching logic.
    
    This is extracted from _generate_banking_build() in build.py.
    Uses the same _defines_label approach as the production code.
    """
    codebook_size = 256 * vec_size
    vq_set = {0} if has_vq else set()
    effective_cb = codebook_size if vq_set else 0

    with open(vq_cfg_path, 'r') as f:
        cfg_lines = f.readlines()

    def _defines_label(lines, label):
        for l in lines:
            stripped = l.strip()
            if stripped.startswith(';'):
                continue
            semi = stripped.find(';')
            code = stripped[:semi].strip() if semi >= 0 else stripped
            if not code.startswith(label):
                continue
            rest = code[len(label):]
            if rest and rest.lstrip().startswith('='):
                return True
        return False

    has_min_vector = _defines_label(cfg_lines, 'MIN_VECTOR')
    has_algo_fixed = _defines_label(cfg_lines, 'ALGO_FIXED')
    has_multi_sample = _defines_label(cfg_lines, 'MULTI_SAMPLE')
    has_pitch_control = _defines_label(cfg_lines, 'PITCH_CONTROL')

    with open(vq_cfg_path, 'w') as f:
        for line in cfg_lines:
            stripped = line.strip()
            if (stripped.startswith("CODEBOOK_SIZE") and
                    stripped[len("CODEBOOK_SIZE"):].lstrip().startswith('=')):
                f.write(f"; {stripped}  ; (overridden)\n")
            else:
                f.write(line)
        f.write(f"\n; === Tracker build pipeline additions ===\n")
        f.write(f"BANK_CODEBOOK_BYTES = {effective_cb}\n")
        if not has_min_vector:
            f.write(f"MIN_VECTOR = {vec_size}\n")
        if not has_algo_fixed:
            f.write(f"ALGO_FIXED = 1\n")
        if not has_multi_sample:
            f.write(f"MULTI_SAMPLE = 1\n")
        if not has_pitch_control:
            f.write(f"PITCH_CONTROL = 1\n")


class TestVqCfgPatching(unittest.TestCase):

    def setUp(self):
        self.tmp = tempfile.mkdtemp()
        self.cfg_path = os.path.join(self.tmp, "VQ_CFG.asm")

    def tearDown(self):
        shutil.rmtree(self.tmp, ignore_errors=True)

    def _read(self):
        with open(self.cfg_path) as f:
            return f.read()

    def test_raw_mode_adds_missing_constants(self):
        """All-RAW build: MIN_VECTOR, ALGO_FIXED, MULTI_SAMPLE, PITCH_CONTROL injected."""
        _make_raw_vq_cfg(self.cfg_path)
        _simulate_vq_cfg_patch(self.cfg_path, vec_size=8, has_vq=False)
        content = self._read()
        self.assertIn("MIN_VECTOR = 8", content)
        self.assertIn("ALGO_FIXED = 1", content)
        self.assertIn("MULTI_SAMPLE = 1", content)
        self.assertIn("PITCH_CONTROL = 1", content)
        self.assertIn("BANK_CODEBOOK_BYTES = 0", content)

    def test_vq_mode_does_not_duplicate(self):
        """VQ build: constants already present → not duplicated."""
        _make_vq_vq_cfg(self.cfg_path)
        _simulate_vq_cfg_patch(self.cfg_path, vec_size=8, has_vq=True)
        content = self._read()
        # Should only have one active MIN_VECTOR (the original)
        active_lines = [l for l in content.splitlines()
                        if 'MIN_VECTOR' in l and '=' in l
                        and not l.strip().startswith(';')]
        self.assertEqual(len(active_lines), 1, 
                         f"Expected 1 active MIN_VECTOR, got: {active_lines}")

    def test_codebook_size_commented_out(self):
        """CODEBOOK_SIZE from converter is commented out to avoid duplicate."""
        _make_vq_vq_cfg(self.cfg_path)
        _simulate_vq_cfg_patch(self.cfg_path, vec_size=8, has_vq=True)
        content = self._read()
        for line in content.splitlines():
            stripped = line.strip()
            if 'CODEBOOK_SIZE' in stripped and '=' in stripped:
                # Must be a comment or the BANK_ version
                self.assertTrue(
                    stripped.startswith(';') or 'BANK_CODEBOOK_BYTES' in stripped,
                    f"Unexpected active CODEBOOK_SIZE: {stripped}")

    def test_raw_mode_bank_codebook_zero(self):
        """All-RAW: BANK_CODEBOOK_BYTES = 0 (no VQ overhead)."""
        _make_raw_vq_cfg(self.cfg_path)
        _simulate_vq_cfg_patch(self.cfg_path, vec_size=8, has_vq=False)
        content = self._read()
        self.assertIn("BANK_CODEBOOK_BYTES = 0", content)

    def test_vq_mode_bank_codebook_nonzero(self):
        """VQ build: BANK_CODEBOOK_BYTES = 256 * vec_size."""
        _make_vq_vq_cfg(self.cfg_path)
        _simulate_vq_cfg_patch(self.cfg_path, vec_size=8, has_vq=True)
        content = self._read()
        self.assertIn("BANK_CODEBOOK_BYTES = 2048", content)

    def test_algo_raw_preserved(self):
        """ALGO_RAW from converter is not removed — both ALGO_RAW and ALGO_FIXED coexist."""
        _make_raw_vq_cfg(self.cfg_path)
        _simulate_vq_cfg_patch(self.cfg_path, vec_size=8, has_vq=False)
        content = self._read()
        # ALGO_RAW should still be there (not removed)
        self.assertIn("ALGO_RAW = 1", content)
        # ALGO_FIXED should be added
        self.assertIn("ALGO_FIXED = 1", content)

    def test_label_detection_no_false_positive(self):
        """Substring matches in comments/other labels must not suppress injection."""
        # Write a VQ_CFG with tricky lines: label substrings and inline comments
        # that mention the target constants but are NOT actual definitions.
        with open(self.cfg_path, 'w') as f:
            f.write("; Configuration generated by PokeyVQ\n")
            f.write("PLAY_RATE = $04\n")
            f.write("CHANNELS = 4\n")
            f.write("ALGO_RAW = 1\n")
            # Tricky: comment on a data line mentions MIN_VECTOR
            f.write("IRQ_MASK = 1   ; see MIN_VECTOR docs\n")
            # Tricky: prefix match — NOT the same label
            f.write("MIN_VECTOR_NOTE = 42\n")
            f.write("ALGO_FIXED_RATE = 100\n")
            f.write("MULTI_SAMPLE_COUNT = 5\n")
            f.write("PITCH_CONTROL_MODE = 2\n")
        _simulate_vq_cfg_patch(self.cfg_path, vec_size=8, has_vq=False)
        content = self._read()
        # All four should be INJECTED because the prefix-named labels
        # are different symbols (MIN_VECTOR_NOTE ≠ MIN_VECTOR)
        self.assertIn("MIN_VECTOR = 8", content)
        self.assertIn("ALGO_FIXED = 1", content)
        self.assertIn("MULTI_SAMPLE = 1", content)
        self.assertIn("PITCH_CONTROL = 1", content)


class TestAsmGuardOrdering(unittest.TestCase):
    """Verify MIN_VECTOR .ifndef guard appears before its first usage."""

    def _first_active_line(self, filepath, needle):
        """Return 1-based line number of first active (non-comment) line containing needle."""
        with open(filepath) as f:
            for i, line in enumerate(f, 1):
                stripped = line.strip()
                if stripped.startswith(';'):
                    continue
                if needle in stripped:
                    return i
        return None

    def test_banked_irq_guard_before_codebook_fallback(self):
        """In tracker_irq_banked.asm, .ifndef MIN_VECTOR must come before
        the .else branch that uses MIN_VECTOR to compute CODEBOOK_SIZE."""
        path = os.path.join(os.path.dirname(__file__), "..", "asm",
                            "tracker", "tracker_irq_banked.asm")
        if not os.path.exists(path):
            self.skipTest("ASM files not present")
        guard = self._first_active_line(path, ".ifndef MIN_VECTOR")
        usage = self._first_active_line(path, "256 * MIN_VECTOR")
        self.assertIsNotNone(guard, ".ifndef MIN_VECTOR not found")
        self.assertIsNotNone(usage, "256 * MIN_VECTOR fallback not found")
        self.assertLess(guard, usage,
                        f".ifndef MIN_VECTOR (line {guard}) must come "
                        f"before 256 * MIN_VECTOR (line {usage})")

    def test_song_player_defaults_before_validation(self):
        """In song_player.asm, .ifndef defaults must come before .error checks."""
        path = os.path.join(os.path.dirname(__file__), "..", "asm",
                            "song_player.asm")
        if not os.path.exists(path):
            self.skipTest("ASM files not present")
        for symbol in ['ALGO_FIXED', 'MULTI_SAMPLE', 'PITCH_CONTROL']:
            default = self._first_active_line(path, f".ifndef {symbol}")
            error = self._first_active_line(path,
                                            f'.error "song_player.asm requires {symbol}')
            if default is None or error is None:
                continue  # skip if symbol not present
            self.assertLess(default, error,
                            f".ifndef {symbol} (line {default}) must come "
                            f"before .error (line {error})")

    def test_irq_handler_before_process_row(self):
        """tracker_irq_banked.asm must be included before process_row.asm
        so CHANNEL_IRQ macro labels are defined before referenced."""
        path = os.path.join(os.path.dirname(__file__), "..", "asm",
                            "song_player.asm")
        if not os.path.exists(path):
            self.skipTest("ASM files not present")
        irq_line = self._first_active_line(path, 'tracker_irq_banked.asm')
        pr_line = self._first_active_line(path, 'process_row.asm')
        self.assertIsNotNone(irq_line, "tracker_irq_banked.asm include not found")
        self.assertIsNotNone(pr_line, "process_row.asm include not found")
        self.assertLess(irq_line, pr_line,
                        f"tracker_irq_banked.asm (line {irq_line}) must be "
                        f"included BEFORE process_row.asm (line {pr_line})")

    def test_irq_macro_labels_use_def_for_global_scope(self):
        """CHANNEL_IRQ macro labels referenced by SETUP_CHANNEL must use
        .def to be globally visible (MADS macro labels are local)."""
        # Labels that process_row.asm SETUP_CHANNEL references from IRQ handler
        global_labels_banked = [
            'ch:1_bank', 'ch:1_tick_jmp',
            'ch:1_vq_no_pitch', 'ch:1_vq_pitch',
            'ch:1_raw_no_pitch', 'ch:1_raw_pitch',
        ]
        global_labels_speed = [
            'ch:1_tick_jmp',
            'ch:1_vq_no_pitch', 'ch:1_vq_pitch',
            'ch:1_raw_no_pitch', 'ch:1_raw_pitch',
        ]
        test_cases = [
            ("tracker/tracker_irq_banked.asm", global_labels_banked),
            ("tracker/tracker_irq_speed.asm", global_labels_speed),
        ]
        for filename, required_defs in test_cases:
            path = os.path.join(os.path.dirname(__file__), "..", "asm", filename)
            if not os.path.exists(path):
                continue
            with open(path) as f:
                # Read only the macro body
                in_macro = False
                macro_lines = []
                for line in f:
                    stripped = line.strip().lower()
                    if stripped.startswith('.macro'):
                        in_macro = True
                    elif in_macro and stripped in ('.endm', '.mend'):
                        in_macro = False
                    elif in_macro:
                        macro_lines.append(line)
            macro_text = ''.join(macro_lines)
            for label in required_defs:
                self.assertIn(f'.def {label}', macro_text,
                              f"{filename}: '{label}' must use .def for global scope")


class TestBuildResultUpgrade(unittest.TestCase):
    """Verify BuildResult memory upgrade signaling."""

    def test_build_result_defaults(self):
        """New BuildResult has needs_upgrade=False by default."""
        from build import BuildResult
        r = BuildResult()
        self.assertFalse(r.needs_upgrade)
        self.assertEqual(r.suggested_config, "")
        self.assertEqual(r.suggested_banks, 0)

    def test_build_result_upgrade_fields(self):
        """BuildResult upgrade fields can be set."""
        from build import BuildResult
        r = BuildResult()
        r.needs_upgrade = True
        r.suggested_config = "320 KB"
        r.suggested_banks = 16
        r.current_config = "128 KB"
        r.total_sample_bytes = 80000
        self.assertTrue(r.needs_upgrade)
        self.assertEqual(r.suggested_config, "320 KB")

    def test_upgrade_signal_format(self):
        """UPGRADE: prefix is parseable into config/banks/bytes/current."""
        signal = "UPGRADE:320 KB:16:80000:128 KB"
        self.assertTrue(signal.startswith("UPGRADE:"))
        parts = signal.split(":")
        self.assertEqual(len(parts), 5)
        self.assertEqual(parts[1], "320 KB")
        self.assertEqual(int(parts[2]), 16)
        self.assertEqual(int(parts[3]), 80000)
        self.assertEqual(parts[4], "128 KB")

    def test_no_auto_upgrade_in_banking_build(self):
        """_generate_banking_build must NOT silently mutate song.memory_config."""
        # Verify the auto-upgrade code pattern is gone from the source
        import inspect
        from build import _generate_banking_build
        source = inspect.getsource(_generate_banking_build)
        # Old pattern: directly changing song.memory_config inside the function
        self.assertNotIn("song.memory_config = cfg_name", source,
                         "_generate_banking_build must not silently mutate "
                         "song.memory_config (removed auto-upgrade)")
        # Old pattern: "Auto-upgraded" log message
        self.assertNotIn("Auto-upgraded", source,
                         "Auto-upgrade log message should be removed")


class TestMemErrTextGeneration(unittest.TestCase):
    """Verify MEM_ERR_TEXT.asm generated error screen text."""

    def setUp(self):
        import tempfile
        self.tmpdir = tempfile.mkdtemp()

    def tearDown(self):
        import shutil
        shutil.rmtree(self.tmpdir, ignore_errors=True)

    def _generate_and_read(self, config, banks, title=""):
        from build import _generate_mem_err_text
        _generate_mem_err_text(self.tmpdir, config, banks, title)
        path = os.path.join(self.tmpdir, "MEM_ERR_TEXT.asm")
        self.assertTrue(os.path.exists(path))
        with open(path) as f:
            return f.read()

    def test_contains_required_labels(self):
        """Generated file must define mem_err_dl, mem_err_text, mem_err_found_digits."""
        content = self._generate_and_read("320 KB", 16)
        self.assertIn("mem_err_dl:", content)
        self.assertIn("mem_err_text:", content)
        self.assertIn("mem_err_found_digits:", content)

    def test_config_name_baked_in(self):
        """Memory config name appears in the error text."""
        content = self._generate_and_read("576 KB", 32)
        self.assertIn("576 KB", content)

    def test_required_banks_baked_in(self):
        """Required bank count is pre-filled (not runtime-patched)."""
        content = self._generate_and_read("320 KB", 16)
        self.assertIn("REQUIRED: 16", content)

    def test_found_digits_placeholder(self):
        """FOUND digits show ?? placeholder for runtime patching."""
        content = self._generate_and_read("128 KB", 4)
        self.assertIn('dta d"??"', content)

    def test_all_text_lines_40_chars(self):
        """Each full dta d line must be exactly 40 characters."""
        import re
        content = self._generate_and_read("320 KB", 16, "Test Song")
        # Extract all dta d"..." strings
        parts = re.findall(r'dta d"(.+?)"', content)
        # Full lines are 40 chars; split parts (line 5) are shorter
        full_lines = [p for p in parts if len(p) == 40]
        short_parts = [p for p in parts if len(p) < 40]
        self.assertGreater(len(full_lines), 0)
        # The 3 short parts (line 5 split) must total 40
        self.assertEqual(sum(len(p) for p in short_parts), 40,
                         f"Split line 5 parts should total 40: {short_parts}")

    def test_song_title_included(self):
        """Song title appears when provided."""
        content = self._generate_and_read("320 KB", 16, "Axel F")
        self.assertIn("AXEL F", content)

    def test_no_title_when_empty(self):
        """No title line when song_title is empty."""
        content = self._generate_and_read("320 KB", 16, "")
        # Should have 5 text lines (no title), count full dta d lines
        import re
        full_lines = re.findall(r'dta d"(.{40})"', content)
        # 4 full lines (line1, line2, line3, line4) + line5 is split
        self.assertEqual(len(full_lines), 4)

    def test_has_org_2000(self):
        """Text block must be at ORG $2000."""
        content = self._generate_and_read("128 KB", 4)
        self.assertIn("ORG $2000", content)

    def test_display_list_structure(self):
        """Display list must have blank lines, LMS, continuations, JVB."""
        content = self._generate_and_read("320 KB", 16)
        self.assertIn("$42", content)   # Mode 2 + LMS
        self.assertIn("$02", content)   # Mode 2 continuation
        self.assertIn("$41", content)   # JVB

    def test_mem_detect_references_generated_labels(self):
        """mem_detect.asm references labels defined in MEM_ERR_TEXT.asm."""
        path = os.path.join(os.path.dirname(__file__), "..", "asm",
                            "banking", "mem_detect.asm")
        if not os.path.exists(path):
            self.skipTest("ASM files not present")
        with open(path) as f:
            asm = f.read()
        # Must reference labels from MEM_ERR_TEXT.asm (forward references
        # resolved by MADS because bank_loader.asm includes both files)
        self.assertIn("mem_err_dl", asm)
        self.assertIn("mem_err_found_digits", asm)
        # MEM_ERR_TEXT.asm is included by bank_loader.asm (top level),
        # NOT by mem_detect.asm (nested icl path resolution is unreliable).
        # Check that no actual icl directive exists (comments mentioning icl are OK).
        for line in asm.split('\n'):
            code = line.split(';')[0].strip()
            self.assertFalse(code.lower().startswith('icl '),
                             f"mem_detect.asm must not have icl directives: {line}")
        # Must NOT have old inline text (removed)
        self.assertNotIn("mem_err_line1:", asm)
        self.assertNotIn("mem_err_need_digits:", asm)


if __name__ == "__main__":
    unittest.main()
