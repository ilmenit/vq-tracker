; ==========================================================================
; MEM_DETECT.ASM - Extended RAM Bank Detection (Alias-Aware)
; ==========================================================================
; Detects available extended memory banks on Atari XL/XE systems.
; Based on the reference detect_ext procedure which correctly handles
; bank aliasing across different memory expansion types.
;
; The detection operates at the 64KB BLOCK level (16 blocks, 4 banks each).
; Within each block, PORTB bits 2,3 select one of 4 physical banks.
; Blocks that alias to the same physical RAM are detected automatically:
; zeroing all blocks, then marking each new block with $FF, causes all
; aliases to be marked simultaneously.
;
; Block probe order: X=15 downto 0 (highest-first for SDX compatibility).
;
; Memory layout:
;   $0600+  Code: detect, validate, error_screen, setpb, byte_to_digits
;           (~220 bytes, stays below $0700 DOS boundary)
;   $2000+  Data: error screen display list + text (in MEM_ERR_TEXT.asm)
;           (overwritten later by song_player.asm — OK, only used on halt)
;
; NOTE: All labels use globally unique "mdet_" prefix because MADS @local
; labels leak across .icl includes, causing collisions with other files.
;
; Requires:
;   REQUIRED_BANKS      — defined by bank_loader.asm before icl
;   MEM_ERR_TEXT.asm    — generated by build pipeline with config-specific
;                         error text (display list + formatted messages)
;
; Result: mem_banks_found = number of distinct 16KB banks available
; ==========================================================================

PORTB_ADDR = $D301
EXT_B      = $4000            ; Test address in bank window

; OS shadow registers (VBI copies these to hardware every frame)
SDLSTL = $0230                ; Display list pointer low
SDLSTH = $0231                ; Display list pointer high
SDMCTL = $022F                ; DMA control
COLOR1 = $02C5                ; COLPF1 shadow
COLOR2 = $02C6                ; COLPF2 shadow
COLOR4 = $02C8                ; COLBK shadow

; ==========================================================================
; MEM_DETECT - Detect extended memory banks (alias-aware)
; ==========================================================================
; Adapted from the reference detect_ext procedure.
; Non-destructive: saves and restores all probed bytes.
;
; Uses mdet_setpb to convert block index X (0-15) to PORTB value.
; Each block X maps to a base PORTB; 4 banks within via bits 2,3.
;
; Output: mem_banks_found = number of distinct banks (multiple of 4)
; ==========================================================================
mem_detect:
    lda PORTB_ADDR
    pha                         ; save current PORTB

    lda #$FF
    sta PORTB_ADDR              ; main RAM: deselect all banks

    lda EXT_B
    pha                         ; save byte at $4000 in main RAM

    ; --- Phase 1: Save byte at $4000 from each of 16 blocks ---
    ldx #$0F
mdet_save_loop:
    jsr mdet_setpb
    lda EXT_B
    sta mdet_block_save,x
    dex
    bpl mdet_save_loop

    ; --- Phase 2: Zero $4000 in all 16 blocks ---
    ; (separate loop because we don't know which blocks alias)
    ldx #$0F
mdet_zero_loop:
    jsr mdet_setpb
    lda #$00
    sta EXT_B
    dex
    bpl mdet_zero_loop

    ; Eliminate base RAM: if some expansion aliases $4000 in main RAM,
    ; mark it as "already seen" so it doesn't get counted.
    ; EXT_B ($4000) and $00 are both in the base 64KB block.
    ; Newell/Wizztronics 256KB maps base $0000-$3FFF into $4000-$7FFF
    ; for some PORTB values. Phase 2 zeroed $4000 through that alias,
    ; which actually zeroed $0000 in base RAM.  Writing $FF to $00
    ; prevents that alias from being falsely counted as a new block.
    stx PORTB_ADDR              ; X=$FF -> select main RAM
    stx EXT_B                   ; write $FF to main RAM $4000
    stx $00                     ; guard for Newell 256KB (aliases base $0000)

    ; --- Phase 3: Count distinct 64KB blocks ---
    ldy #$00                    ; Y = banks found counter
    ldx #$0F                    ; probe blocks 15 down to 0
mdet_count_loop:
    jsr mdet_setpb
    lda EXT_B                   ; if non-zero, block already counted (alias)
    bne mdet_count_skip

    dec EXT_B                   ; mark as counted (write $FF via 0-1=$FF)
    lda EXT_B                   ; verify the write took effect
    bpl mdet_count_skip         ; if bit 7 not set, hardware issue -> skip

    iny                         ; count 4 banks for this block
    iny
    iny
    iny

mdet_count_skip:
    dex
    bpl mdet_count_loop

    sty mem_banks_found

    ; --- Phase 4: Restore all saved bytes ---
    ldx #$0F
mdet_restore_loop:
    jsr mdet_setpb
    lda mdet_block_save,x
    sta EXT_B
    dex
    bpl mdet_restore_loop

    stx PORTB_ADDR              ; X=$FF -> select main RAM

    pla
    sta EXT_B                   ; restore main RAM $4000

    pla
    sta PORTB_ADDR              ; restore original PORTB
    rts

; ==========================================================================
; MDET_SETPB - Convert block index to PORTB value
; ==========================================================================
; Input:  X = block index (0-15), format %0000dcba
; Output: PORTB set to %cba000d1
;   - Bits 7,6,5 = c,b,a (block address upper bits)
;   - Bit 4 = 0 (CPU bank enable = ON)
;   - Bits 3,2 = 0,0 (selects bank 0 within block)
;   - Bit 1 = d (block address lower bit, via ADC carry trick)
;   - Bit 0 = 1 (OS ROM enabled - safe during detection)
;
; This is the reference setpb routine:
;   txa / lsr / ror / ror / ror  -> %cba00000, C=d
;   adc #$01                     -> sets bit 1 from carry (d)
;   ora #$01                     -> sets bit 0 (OS ROM)
; ==========================================================================
mdet_setpb:
    txa
    lsr                         ; A=%00000dcb, C=a
    ror                         ; A=%a00000dc, C=b
    ror                         ; A=%ba00000d, C=c
    ror                         ; A=%cba00000, C=d
    adc #$01                    ; C=d: if d=0 -> bit1=0; if d=1 -> bit1=1
    ora #$01                    ; bit 0 = 1 (OS ROM on)
    sta PORTB_ADDR
    rts

; ==========================================================================
; Storage
; ==========================================================================
mem_banks_found: .byte 0
mdet_block_save: .ds 16         ; saved bytes from 16 blocks

; ==========================================================================
; MEM_VALIDATE - Verify required banks are available
; ==========================================================================
; After alias-aware mem_detect has counted distinct physical banks,
; compare the count against REQUIRED_BANKS. If insufficient, display
; error screen and halt.
; ==========================================================================
mem_validate:
    lda mem_banks_found
    cmp #REQUIRED_BANKS
    bcs mdet_validate_pass
    ; Insufficient banks - show error and halt
    jmp mem_validate_fail

mdet_validate_pass:
    rts

mem_validate_fail:
    jsr mem_error_screen
    jmp *                       ; Halt forever

; ==========================================================================
; MEM_ERROR_SCREEN - Display error and freeze
; ==========================================================================
; Writes BOTH OS shadow registers (for persistence across VBI frames)
; and hardware registers (for immediate visibility).
;
; The error text labels (mem_err_dl, mem_err_found_digits) are defined
; in MEM_ERR_TEXT.asm, generated by the build pipeline with config-
; specific messaging (e.g. "REQUIRES 320 KB RAM").
; ==========================================================================
mem_error_screen:
    ; Briefly disable NMI to prevent VBI interference during setup
    lda #0
    sta $D40E                   ; NMIEN = 0

    ; Silence audio
    sta $D208                   ; AUDCTL = 0
    sta $D200                   ; AUDF1 = 0
    sta $D201                   ; AUDC1 = 0

    ; Set display list via OS shadow registers (persists across VBI)
    lda #<mem_err_dl
    sta SDLSTL
    lda #>mem_err_dl
    sta SDLSTH

    ; Set colors — red scheme for error visibility
    lda #$00
    sta COLOR4                  ; COLBK = black border
    lda #$0E
    sta COLOR1                  ; COLPF1 = white text
    lda #$46
    sta COLOR2                  ; COLPF2 = dark red background

    ; Enable display via shadow
    lda #$22
    sta SDMCTL                  ; DL DMA + normal playfield

    ; Also write hardware directly for immediate effect (before VBI fires)
    lda #<mem_err_dl
    sta $D402                   ; DLISTL
    lda #>mem_err_dl
    sta $D403                   ; DLISTH
    lda #$00
    sta $D01A                   ; COLBK
    lda #$0E
    sta $D016                   ; COLPF1
    lda #$46
    sta $D017                   ; COLPF2
    lda #$22
    sta $D400                   ; DMACTL

    ; Patch "FOUND: ??" with actual detected bank count
    ; (NEED value is pre-filled by build pipeline)
    lda mem_banks_found
    jsr mdet_byte_to_digits
    sta mem_err_found_digits+1
    stx mem_err_found_digits

    ; Re-enable NMI so VBI maintains display from shadow registers
    lda #$C0
    sta $D40E                   ; NMIEN = VBI + DLI

    rts

; ==========================================================================
; Convert byte in A to two screen-code digit chars
; Returns: X = tens digit (screen code), A = ones digit (screen code)
; ==========================================================================
mdet_byte_to_digits:
    ldx #$10                    ; Screen code '0' for tens
    sec
mdet_btd_sub:
    sbc #10
    bcc mdet_btd_done
    inx
    jmp mdet_btd_sub
mdet_btd_done:
    adc #10                     ; undo last subtraction
    ora #$10                    ; convert to screen code digit
    rts

; NOTE: Error screen text (display list + formatted messages) is in
; MEM_ERR_TEXT.asm, generated per-build by the build pipeline and
; included by bank_loader.asm immediately after this file.
; Labels used: mem_err_dl, mem_err_found_digits
