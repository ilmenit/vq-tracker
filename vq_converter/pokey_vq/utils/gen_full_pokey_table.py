import numpy as np
import os

# Base Single Channel Table (Normalized to 0.0-1.0 roughly, but values < 0.6)
# Ideally we should use raw values if we want absolute precision, but these are from empirical measurements/emulation
POKEY_VOLTAGE_TABLE = np.array([
0.000000, 0.049931, 0.097507, 0.142837, 0.186029, 0.227182, 0.266394, 0.303756, 
0.339355, 0.373274, 0.405593, 0.436387, 0.465727, 0.493684, 0.520321, 0.545702
], dtype=np.float32)

def mix_vol_saturated(val1, val2):
    """
    Simulates POKEY's non-linear mixing saturation.
    Model based on Altirra Hardware Reference:
    - Linear up to max volume of single channel.
    - Above that, saturation kicks in.
    - "Two channels at volume 15 only achieve about 50% higher amplitude than a single channel"
    
    Target:
      Input 1.0 (1 chan) -> Output 1.0
      Input 2.0 (2 chans) -> Output 1.5
      Slope for excess = 0.5
    """
    raw_sum = val1 + val2
    # Single channel max (Volume 15)
    max_lin = POKEY_VOLTAGE_TABLE[15] 
    
    if raw_sum <= max_lin:
        return raw_sum
    else:
        excess = raw_sum - max_lin
        # Apply 0.5 slope to the excess
        return max_lin + (excess * 0.5)

def generate_tables():
    # 1. Generate Standard Dual Channel Pairs (DC + DC)
    # Vol = Saturated(V1 + V2)
    pairs_std = []
    for v1 in range(16):
        for v2 in range(16):
            # Apply Saturation Model
            vol = mix_vol_saturated(POKEY_VOLTAGE_TABLE[v1], POKEY_VOLTAGE_TABLE[v2])
            byte_val = (v1 << 4) | v2
            pairs_std.append((vol, byte_val))
            
    # 2. Generate HiFi Pairs (PDM - Pulse Density Modulation)
    # 
    # PDM uses software PWM to achieve true 8-bit resolution:
    #   - High Nibble (v1) -> Ch1 = MSB (constant DC level)
    #   - Low Nibble (v2)  -> Ch2 = LSB (pulsed for 1/16 of sample period)
    #
    # The player pulses Ch2 ON for 1/16 of the sample time, then OFF.
    # This averages to 1/16 (0.0625) of the voltage contribution.
    # The saturation still applies to the instantaneous sum, but since we are calculating
    # the *effective* average voltage, we should ideally integrate the saturated waveform.
    #
    # Waveform over 16 cycles:
    #   1 cycle:  Saturated(V1 + V2)
    #   15 cycles: Saturated(V1 + 0)  [Assuming V2 is OFF]
    #
    # Average = (1 * Saturated(V1 + V2) + 15 * Saturated(V1)) / 16
    # Note: Saturated(V1) is just V1 because single channel is linear.
    
    pairs_hifi = []
    for v1 in range(16):  # High Nibble (Ch1, MSB - constant)
        for v2 in range(16): # Low Nibble (Ch2, LSB - pulsed 1/16)
            
            val_v1 = POKEY_VOLTAGE_TABLE[v1]
            val_v2 = POKEY_VOLTAGE_TABLE[v2]
            
            # Peak voltage during the pulse
            peak_vol = mix_vol_saturated(val_v1, val_v2)
            # Base voltage (just V1)
            base_vol = val_v1 # Saturated(val_v1 + 0) == val_v1 since val_v1 <= max_lin
            
            # Weighted average
            vol = (peak_vol * 1.0 + base_vol * 15.0) / 16.0
            
            byte_val = (v1 << 4) | v2
            pairs_hifi.append((vol, byte_val))
            
    # Process Standard
    pairs_std.sort(key=lambda x: x[0])
    unique_vols_std, vol_to_byte_std, vals_str_std = _uniquify(pairs_std)
    
    # Process HiFi
    pairs_hifi.sort(key=lambda x: x[0])
    unique_vols_hifi, vol_to_byte_hifi, vals_str_hifi = _uniquify(pairs_hifi)
    
    # Generate Dual Balanced (Standard)
    balanced_levels = []
    for i in range(31):
        v1 = i // 2
        v2 = i - v1
        vol = POKEY_VOLTAGE_TABLE[v1] + POKEY_VOLTAGE_TABLE[v2]
        balanced_levels.append(vol)

    # --- Output Writer ---
    lines = []
    lines.append("import numpy as np")
    lines.append("")
    lines.append("# Generated by pokey_vq/utils/gen_full_pokey_table.py")
    lines.append("POKEY_VOLTAGE_TABLE = np.array([")
    lines.append(", ".join([f"{x:.6f}" for x in POKEY_VOLTAGE_TABLE]))
    lines.append("], dtype=np.float32)")
    lines.append("")
    
    lines.append("# Balanced Dual Channel Table (31 levels) - Standard Mode")
    lines.append("POKEY_VOLTAGE_TABLE_DUAL = np.array([")
    lines.append(", ".join([f"{x:.6f}" for x in balanced_levels]))
    lines.append("], dtype=np.float32)")
    lines.append("")
    
    lines.append("# Full Dual Channel Table (Sorted Unique Voltages) - Standard Mode")
    lines.append("POKEY_VOLTAGE_TABLE_FULL = np.array([")
    lines.append(", ".join(vals_str_std))
    lines.append("], dtype=np.float32)")
    lines.append("")
    
    lines.append("# Map: Index in FULL -> Byte (Standard)")
    lines.append("POKEY_MAP_FULL = np.array([")
    lines.append(", ".join([str(vol_to_byte_std[v]) for v in unique_vols_std]))
    lines.append("], dtype=np.uint8)")
    lines.append("")
    
    # Write to core/pokey_table.py (relative to this script?)
    # We assume we are running from project root usually, but let's be safe.
    # The original script wrote to 'src/pokey_table.py' but we want 'atari-player/pokey_vq/core/pokey_table.py'
    
    target_path = os.path.join("pokey_vq", "core", "pokey_table.py")
    # If not found, try varying paths or just write to where we think it is.
    if not os.path.exists(os.path.dirname(target_path)):
         # try simpler path if running inside folder
         if os.path.exists("../core"):
             target_path = "../core/pokey_table.py"
         
    with open(target_path, 'w', encoding='utf-8') as f:
        f.write("\n".join(lines))
    print(f"Generated {target_path}")

def _uniquify(pairs):
    unique_vols = []
    vol_to_byte = {}
    vals_str = []
    
    for vol, byte_val in pairs:
        if not unique_vols or abs(vol - unique_vols[-1]) > 1e-6:
            unique_vols.append(vol)
            vol_to_byte[vol] = byte_val
            vals_str.append(f"{vol:.6f}")
    
    return unique_vols, vol_to_byte, vals_str

if __name__ == "__main__":
    generate_tables()
