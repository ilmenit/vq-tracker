; ==========================================================================
; POKEY RAW PLAYER (Refactored)
; --------------------------------------------------------------------------
; Specialized player for uncompressed 4-bit/8-bit audio streams.
; Optimized for maximum speed and minimal CPU overhead.
;
; Supported Modes:
;   - Mono (4-bit/Packed) or Stereo (8-bit/Interleaved)
;   - Standard (Size Optimized) or Fast (Speed Optimized)
; ==========================================================================

    icl "common/atari.inc"
    
    ; USE_STACK_IRQ = 1 ; Removed to use zeropage variables
    icl "common/zeropage.inc"
    icl "common/macros.inc"
    
    ; Load Configuration (Generated by CLI)
    icl "VQ_CFG.asm"
    .ifndef ALGO_RAW
        .error "raw_player.asm requires ALGO_RAW=1"
    .endif

    org $2000

; --- DISPLAY LIST ---
dlist:
    .byte $70,$70,$70
    .byte $41,<dlist,>dlist

start:
    ; --- 1. System Cleanup ---
    sei             ; Disable interrupts
    cld             ; Clear decimal mode
    lda #0
    sta NMIEN       ; Disable NMI
    sta IRQEN       ; Disable IRQ
    lda #$FE        ; Enable RAM
    sta PORTB       ; Enable RAM for vector writing safely
    
    ; --- 2. Memory/Pointer Setup ---
    ; Point to RAW_DATA start
    lda #<RAW_DATA
    sta sample_ptr
    lda #>RAW_DATA
    sta sample_ptr+1

    ; Calculate End Address (Start + Len)
    clc
    lda sample_ptr
    adc #<RAW_DATA_LEN
    sta stream_end
    lda sample_ptr+1
    adc #>RAW_DATA_LEN
    sta stream_end+1

    ; Reset State
    lda #0
    sta nibble_state   ; 0 = Low Nibble (First), 1 = High Nibble? 
                       ; Wait, depends on packing order. 
                       ; Standard packing: High Nibble = T+1, Low Nibble = T ?
                       ; play_routine says: do_low_nibble (Frame T), do_high_nibble (Frame T+1).
                       ; So start with LOW nibble (if packed). 
                       ; Actually, standard packing usually puts Frame T in High/Low?
                       ; Check play_routine:
                       ; do_high_nibble -> inc sample_ptr.
                       ; do_low_nibble -> inc nibble_state.
                       ; So Low is FIRST part of byte. 
    
    ; --- 3. Hardware Setup ---
    jsr Pokey_Setup ; Implemented in common/pokey_setup.asm    ; Initialize POKEY (Frequency, Volume Only bits)
    
    ; --- 4. Interrupt Setup ---
    lda #<nmi
    sta $FFFA
    lda #>nmi
    sta $FFFA+1

    lda #<IRQ_Handler
    sta $FFFE
    lda #>IRQ_Handler
    sta $FFFF

    ; Enable Timer 1 IRQ
    lda #IRQ_MASK      ; Defined in VQ_CFG (usually 1 or 4)
    sta IRQEN
    
    ; Enable POKEY Timer
    lda #$00           ; Reset all
    sta STIMER
    
    ; Enable NMI
    lda #$C0
    sta NMIEN
    
    cli        ; Enable Interrupts
    
    ; Setup Display
    lda #<dlist
    sta DLISTL
    lda #>dlist
    sta DLISTH
    lda #34
    sta DMACTL

background_loop:
    jmp background_loop
    
nmi:
    rti

; ==========================================================================
; IRQ HANDLER (Critical Path)
; ==========================================================================
IRQ_Handler:
    sta irq_save_a
    stx irq_save_x
    sty irq_save_y
    
    ; ACK IRQ
    ; ACK IRQ (Disable/Enable toggle required)
    lda #0
    sta IRQEN
    lda #IRQ_MASK
    sta IRQEN

    ; --- CHECK END OF STREAM ---
    ; (Optimized: Check High byte first usually enough if aligned? No.)
    ; Standard checks
    lda sample_ptr+1
    cmp stream_end+1
    bne process_audio
    lda sample_ptr
    cmp stream_end
    bne process_audio
    
    ; End Reached
    jsr Restart_Stream
    jmp exit_irq

process_audio:
    ; --- PLAYBACK LOGIC ---
    .if CHANNELS == 1
        ; MONO
        .ifdef USE_FAST_CPU
             ; FAST MONO (LUT_NIBBLES)
             lda nibble_state
             bne do_high_nibble
             
        do_low_nibble:
             ldy #0
             lda (sample_ptr),y
             tay
             lda lut_lo,y
             sta AUDC1
             inc nibble_state
             jmp exit_irq
             
        do_high_nibble:
             ldy #0
             lda (sample_ptr),y
             tay
             lda lut_hi,y
             sta AUDC1
             
             ; Advance Pointer
             inc sample_ptr
             bne @+
             inc sample_ptr+1
             @:
             lda #0
             sta nibble_state
        .else
             ; STANDARD MONO (No LUT, Shift-based)
             lda nibble_state
             bne do_high_nibble_std
             
        do_low_nibble_std:
             ldy #0
             lda (sample_ptr),y
             and #$0F
             ora #AUDC1_MASK
             sta AUDC1
             inc nibble_state
             jmp exit_irq
             
        do_high_nibble_std:
             ldy #0
             lda (sample_ptr),y
             lsr @
             lsr @
             lsr @
             lsr @
             ora #AUDC1_MASK
             sta AUDC1
             
             ; Advance Pointer
             inc sample_ptr
             bne @+
             inc sample_ptr+1
             @:
             lda #0
             sta nibble_state
        .endif
        
    .else
        ; STEREO
        ; Assuming 2 bytes per sample for max quality/simplicity in RAW?
        ; Or 1 byte split?
        ; Standard VQ uses 1 byte split.
        ; RAW usually means high quality -> 4-bit + 4-bit (1 byte).
        
        .ifdef USE_FAST_CPU
            ; FAST STEREO (2 bytes per sample, pre-calculated)
            ; Byte 0: AUDC2 value (or AUDC1? Encoder says: v2_reg (Ch1), v1_reg (Ch2))
            ; Encoder: raw_data = np.dstack((val_c1, val_c2)).flatten()
            ; So Byte 0 = Ch1 (AUDC1), Byte 1 = Ch2 (AUDC2)
            
            ldy #0
            lda (sample_ptr),y
            sta AUDC1
            
            iny
            lda (sample_ptr),y
            sta AUDC2
            
            ; Advance Pointer by 2
            clc
            lda sample_ptr
            adc #2
            sta sample_ptr
            bcc @+
            inc sample_ptr+1
            @:
        .else
            ; STANDARD STEREO (1 byte per sample, packed 4+4)
            ldy #0
            lda (sample_ptr),y
            
            tax ; Save
            and #$0F
            ora #AUDC1_MASK
            tay
            
            txa
            lsr @
            lsr @
            lsr @
            lsr @
            ora #AUDC2_MASK
            ; A = CH2, Y = CH1
            
            sty AUDC1
            sta AUDC2
            
            inc sample_ptr
            bne @+
            inc sample_ptr+1
            @:
        .endif
    .endif

exit_irq:
    lda irq_save_a
    ldx irq_save_x
    ldy irq_save_y
    rti

Restart_Stream:
    lda #<RAW_DATA
    sta sample_ptr
    lda #>RAW_DATA
    sta sample_ptr+1
    lda #0
    sta nibble_state
    rts

; --- SHARED HELPERS ---
    icl "common/pokey_setup.asm"

.ifdef USE_FAST_CPU
    .align $100
lut_lo:
    :256 dta AUDC1_MASK | [#&$0F]
lut_hi:
    :256 dta AUDC1_MASK | [#>>4]
.endif

; --- DATA ---
    ; Included at end
    icl "RAW_DATA.asm"

    run start
